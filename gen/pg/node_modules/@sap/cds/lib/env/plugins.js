// REVISIT: we should have a real modular plugin technique for cds.env
module.exports = function add_mtx_env (env) {

  if (cds_load_mismatch())  return env

  const mtx_env = _require('@sap/cds-mtxs/env')
  if (mtx_env) {
    const {requires} = env, {kinds} = requires
    Object.assign (env, mtx_env, {requires})
    Object.assign (requires, mtx_env.requires, {kinds})
    Object.assign (kinds, mtx_env.requires?.kinds)
  }
  return env
}

function _require (id) {
  try { return module.require(id) }
  catch(e) { if (e.code !== 'MODULE_NOT_FOUND') throw e }
}

// Anticipates if loading mtxs would load a _different_ @sap/cds than this one, which we must avoid.
// May happen in PNPM setups that add all global installs to NODE_PATH. Seen in BAS.
function cds_load_mismatch() {
  const cds = require('..')
  try {
    const mtxs = require.resolve('@sap/cds-mtxs')
    const cds2 = require.resolve('@sap/cds/package.json', { paths:[mtxs] })
    const csd2Home = cds.utils.path.resolve(cds2, '..')
    if (csd2Home !== cds.home) {
      return true
    }
    // console.log('home', cds.home, 'other', otherCdsHome)
  } catch(e) { if (e.code !== 'MODULE_NOT_FOUND') throw e }
}
