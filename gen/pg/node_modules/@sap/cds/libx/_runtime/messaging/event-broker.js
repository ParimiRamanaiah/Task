const cds = require('../cds')

const normalizeIncomingMessage = require('./common-utils/normalizeIncomingMessage')
const express = require('express')
const https = require('https')
const crypto = require('crypto')

async function request(options, data) {
  return new Promise((resolve, reject) => {
    const req = https.request(options, res => {
      const chunks = []
      res.on('data', chunk => {
        chunks.push(chunk)
      })
      res.on('end', () => {
        const response = {
          statusCode: res.statusCode,
          headers: res.headers,
          body: Buffer.concat(chunks).toString()
        }
        if (res.statusCode > 299) {
          reject({ message: response.body })
        } else {
          resolve(response)
        }
      })
    })
    req.on('error', error => {
      reject(error)
    })
    if (data) {
      req.write(JSON.stringify(data))
    }
    req.end()
  })
}

function _validateCertificate(req, res, next) {
  this.LOG.debug('event broker trying to authenticate via mTLS')

  if (req.headers['x-ssl-client-verify'] !== '0') {
    this.LOG.info('cf did not validate client certificate.')
    return res.status(401).json({ message: 'Authentication Failed' })
  }

  if (!req.headers['x-forwarded-client-cert']) {
    this.LOG.info('no certificate in xfcc header.')
    return res.status(401).json({ message: 'Authentication Failed' })
  }

  const clientCertObj = new crypto.X509Certificate(
    `-----BEGIN CERTIFICATE-----\n${req.headers['x-forwarded-client-cert']}\n-----END CERTIFICATE-----`
  )
  const clientCert = clientCertObj.toLegacyObject()

  if (!this.isMultitenancy && !clientCertObj.checkPrivateKey(this.privateKey))
    return res.status(401).josn({ message: 'Authentication Failed' })

  const cfSubject = Buffer.from(req.headers['x-ssl-client-subject-cn'], 'base64').toString()
  if (this.validationCert.subject.CN !== clientCert.subject.CN || this.validationCert.subject.CN !== cfSubject) {
    this.LOG.info('certificate subject does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming Subject CN is valid.')

  if (this.validationCert.issuer.CN !== clientCert.issuer.CN) {
    this.LOG.info('Certificate issuer subject does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming issuer subject CN is valid.')

  if (this.validationCert.issuer.O !== clientCert.issuer.O) {
    this.LOG.info('Certificate issuer org does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('incoming Issuer Org is valid.')

  if (this.validationCert.issuer.OU !== clientCert.issuer.OU) {
    this.LOG.info('certificate issuer OU does not match')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
  this.LOG.debug('certificate issuer OU is valid.')

  const valid_from = new Date(clientCert.valid_from)
  const valid_to = new Date(clientCert.valid_to)
  const now = new Date(Date.now())
  if (valid_from <= now && valid_to >= now) {
    this.LOG.debug('certificate validation completed')
    next()
  } else {
    this.LOG.error('Certificate expired')
    return res.status(401).json({ message: 'Authentication Failed' })
  }
}

let instantiated = false

class EventBroker extends cds.MessagingService {
  async init() {
    // TODO: Only needed if there are subscriptions
    if (instantiated)
      throw new Error('Event Broker service must be a singleton service, you cannot have more than one instance.')
    instantiated = true
    await super.init()
    cds.once('listening', () => {
      this.startListening()
    })
    this.agent = this.getAgent()
    this.isMultitenancy = cds.requires.multitenancy || cds.env.profiles.includes('mtx-sidecar')
    this.validationCert = new crypto.X509Certificate(
      this.isMultitenancy ? this.options.credentials.certificate : this.agent.options.cert
    ).toLegacyObject()
    this.privateKey = !this.isMultitenancy && crypto.createPrivateKey(this.agent.options.key)
  }

  getAgent() {
    try {
      if (this.options.x509.certPath && this.options.x509.pkeyPath) {
        return new https.Agent({
          cert: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.certPath)),
          key: cds.utils.fs.readFileSync(cds.utils.path.resolve(cds.root, this.options.x509.pkeyPath))
        })
      }
    } catch (error) {
      if (this.LOG) this.LOG.error('GetCredentials', { error: error.message })
      throw error
    }
  }

  async handle(msg) {
    if (msg.inbound) return super.handle(msg)
    const _msg = this.message4(msg)
    await this.emitToEventBroker(_msg)
  }

  async startListening() {
    if (!this._listenToAll.value && !this.subscribedTopics.size) return
    await this.registerWebhookEndpoints()
  }

  async emitToEventBroker(msg) {
    // TODO: CSN definition probably not needed, just in case...
    //   See if there's a CSN entry for that event
    //   const found = cds?.model.definitions[topicOrEvent]
    //   if (found) return found  // case for fully-qualified event name
    //   for (const def in cds.model?.definitions) {
    //     const definition = cds.model.definitions[def]
    //     if (definition['@topic'] === topicOrEvent) return definition
    //   }

    // TODO: What if we're in single tenant variant?
    try {
      const hostname = this.options.credentials.eventing.http.x509.url.replace(/^https?:\/\//, '')

      // take over and cleanse cloudevents headers
      const headers = { ...(msg.headers ?? {}) }

      const ceId = headers.id
      delete headers.id

      const ceSource = headers.source
      delete headers.source

      const ceType = headers.type
      delete headers.type

      const ceSpecversion = headers.specversion
      delete headers.specversion

      // const ceDatacontenttype = headers.datacontenttype // not part of the HTTP API
      delete headers.datacontenttype

      // const ceTime  = headers.time // not part of the HTTP API
      delete headers.time

      const options = {
        hostname: hostname,
        method: 'POST',
        headers: {
          'ce-id': ceId,
          'ce-source': ceSource,
          'ce-type': ceType,
          'ce-specversion': ceSpecversion,
          'Content-Type': 'application/json' // because of { data, ...headers } format
        },
        agent: this.agent
      }
      this.LOG.debug('HTTP headers:', JSON.stringify(options.headers))
      this.LOG.debug('HTTP body:', JSON.stringify(msg.data))
      // what about headers?
      // TODO: Clarify if we should send `{ data, ...headers }` vs.  `data` + HTTP headers (`ce-*`)
      await request(options, { data: msg.data, ...headers }) // TODO: fetch does not work with mTLS as of today, requires another module. see https://github.com/nodejs/node/issues/48977
      if (this.LOG._info) this.LOG.info('Emit', { topic: msg.event })
    } catch (e) {
      this.LOG.error('Emit failed:', e.message)
    }
  }

  prepareHeaders(headers, event) {
    if (!('source' in headers)) {
      if (!this.options.credentials.ceSource)
        throw new Error(
          'Cannot publish event because of missing source information, currently not part of binding information.'
        )
      headers.source = `${this.options.credentials.ceSource[0]}/${cds.context.tenant}`
    }
    super.prepareHeaders(headers, event)
  }

  async registerWebhookEndpoints() {
    const webhookBasePath = this.options.webhookPath || '/-/cds/event-broker/webhook'
    cds.app.post(webhookBasePath, _validateCertificate.bind(this))
    cds.app.post(webhookBasePath, express.json())
    cds.app.post(webhookBasePath, this.onEventReceived.bind(this))
  }

  async onEventReceived(req, res) {
    try {
      const event = req.headers['ce-type'] // TG27: type contains namespace, so there's no collision
      const tenant = req.headers['ce-sapconsumertenant']

      // take over cloudevents headers (`ce-*`) without the prefix
      const headers = {}
      for (const header in req.headers) {
        if (header.startsWith('ce-')) headers[header.slice(3)] = req.headers[header]
      }

      const msg = normalizeIncomingMessage(req.body)
      msg.event = event
      Object.assign(msg.headers, headers)
      if (this.isMultitenancy) msg.tenant = tenant

      // for cds.context.http
      msg._ = {}
      msg._.req = req
      msg._.res = res

      const context = { user: cds.User.privileged, _: msg._ }
      if (msg.tenant) context.tenant = msg.tenant

      await this.tx(context, tx => tx.emit(msg))
      this.LOG.debug('Event processed successfully.')
      return res.status(200).json({ message: 'OK' })
    } catch (e) {
      this.LOG.error('ERROR during inbound event processing:', e) // TODO: How does Event Broker do error handling?
      res.status(500).json({ message: 'Internal Server Error!' })
      throw e
    }
  }
}

module.exports = EventBroker
